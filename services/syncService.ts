
import LZString from 'lz-string';
import { db } from '../db/db';
import { Sale, Product } from '../types';

const SYNC_HEADER = "NS_V2_";

/**
 * Generates a unique 16-character alphanumeric sync key for the shop.
 */
export const generateSyncKey = (): string => {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ0123456789';
  const part = () => Array.from({ length: 4 }, () => chars.charAt(Math.floor(Math.random() * chars.length))).join('');
  return `NS-${part()}-${part()}-${part()}`;
};

/**
 * Encrypts/Decrypts a string using a XOR cipher with the shop's sync key.
 */
const xorCipher = (text: string, key: string): string => {
  if (!key) return text;
  return text.split('').map((char, i) => 
    String.fromCharCode(char.charCodeAt(0) ^ key.charCodeAt(i % key.length))
  ).join('');
};

/**
 * Enhanced export function with summaries and staff detection
 */
export const exportDataForWhatsApp = async (type: 'SALES' | 'STOCK' | 'KEY_UPDATE', key: string, staffName: string = 'Staff') => {
  let dataToExport: any = {};
  let summary = "";
  
  if (type === 'SALES') {
    const pendingSales = await db.sales.where('sync_status').equals('pending').toArray();
    const totalRevenue = pendingSales.reduce((acc, s) => acc + s.total_amount, 0);
    const totalItems = pendingSales.reduce((acc, s) => acc + s.items.length, 0);

    dataToExport = {
      type: 'SALES_REPORT',
      staff_name: staffName,
      sales: pendingSales,
      timestamp: Date.now()
    };

    summary = `NaijaShop Report: ${staffName} | Sales: â‚¦${totalRevenue.toLocaleString()} | Items: ${totalItems}`;

  } else if (type === 'STOCK') {
    const masterStock = await db.products.toArray();
    dataToExport = {
      type: 'STOCK_UPDATE',
      products: masterStock,
      timestamp: Date.now()
    };
    summary = `ðŸ“¦ NaijaShop Master Stock Update (${masterStock.length} Items)`;
  } else if (type === 'KEY_UPDATE') {
    dataToExport = {
      type: 'KEY_UPDATE',
      new_key: key,
      timestamp: Date.now()
    };
    summary = "ðŸ” Security Bridge Key Update";
  }

  const jsonString = JSON.stringify(dataToExport);
  const encrypted = xorCipher(jsonString, key);
  const compressed = LZString.compressToEncodedURIComponent(encrypted);
  
  return {
    raw: SYNC_HEADER + compressed,
    summary
  };
};

/**
 * The Engine: Processes staff sync with deduplication and stock subtraction
 */
export const importWhatsAppBridgeData = async (rawString: string, localKey: string) => {
  try {
    if (!rawString.startsWith(SYNC_HEADER)) {
      throw new Error("Invalid Data: This link was not generated by a NaijaShop Terminal.");
    }

    const compressed = rawString.replace(SYNC_HEADER, "");
    const encrypted = LZString.decompressFromEncodedURIComponent(compressed);
    if (!encrypted) throw new Error("Decompression failed. Data may be corrupt.");
    
    const jsonString = xorCipher(encrypted, localKey);
    let payload;
    try {
      payload = JSON.parse(jsonString);
    } catch (e) {
      throw new Error("Sync Key Mismatch: Your terminal's security key does not match the sender's.");
    }

    if (payload.type === 'KEY_UPDATE') {
      await db.settings.update('app_settings', { sync_key: payload.new_key });
      return { success: true, type: 'KEY_UPDATE' };
    }

    if (payload.type === 'SALES_REPORT') {
      let importedCount = 0;
      let skippedCount = 0;

      await (db as any).transaction('rw', [db.sales, db.products, db.inventory_logs], async () => {
        for (const sale of payload.sales) {
          // Point 1: Deduplication logic using UUID
          const exists = await db.sales.where('sale_id').equals(sale.sale_id).first();
          
          if (!exists) {
            // Point 5: Automated Stock Subtraction Engine
            await db.sales.add({ ...sale, sync_status: 'synced' });
            
            for (const item of sale.items) {
              const product = await db.products.get(item.productId);
              if (product) {
                const oldStock = product.stock_qty;
                const newStock = Math.max(0, product.stock_qty - item.quantity);
                
                await db.products.update(item.productId, { stock_qty: newStock });
                
                // Log the movement for Admin's Ledger
                await db.inventory_logs.add({
                  product_id: item.productId,
                  product_name: item.name,
                  quantity_changed: -item.quantity,
                  old_stock: oldStock,
                  new_stock: newStock,
                  type: 'Sale',
                  timestamp: Date.now(),
                  performed_by: `Sync Bridge (${payload.staff_name || 'Staff'})`
                });
              }
            }
            importedCount++;
          } else {
            skippedCount++;
          }
        }
      });
      return { success: true, type: 'SALES', count: importedCount, skipped: skippedCount };
    }

    if (payload.type === 'STOCK_UPDATE') {
      // Point 4: Overwrite local stock with Admin's Master Total
      await (db as any).transaction('rw', [db.products], async () => {
        await db.products.clear();
        await db.products.bulkAdd(payload.products);
      });
      await db.settings.update('app_settings', { last_synced_timestamp: Date.now() });
      return { success: true, type: 'STOCK', count: payload.products.length };
    }

    throw new Error("Unknown payload type.");
  } catch (err: any) {
    console.error("Import Error:", err);
    throw err;
  }
};
