import LZString from 'lz-string';
import { db } from '../db/db';
import { Sale, Product } from '../types';

const SYNC_HEADER = "NS_V2_";

/**
 * Generates a unique 16-character alphanumeric sync key for the shop.
 */
export const generateSyncKey = (): string => {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ0123456789';
  const part = () => Array.from({ length: 4 }, () => chars.charAt(Math.floor(Math.random() * chars.length))).join('');
  return `NS-${part()}-${part()}-${part()}`;
};

/**
 * Encrypts/Decrypts a string using a XOR cipher with the shop's sync key.
 */
const xorCipher = (text: string, key: string): string => {
  if (!key) return text;
  return text.split('').map((char, i) => 
    String.fromCharCode(char.charCodeAt(0) ^ key.charCodeAt(i % key.length))
  ).join('');
};

export const exportDataForWhatsApp = async (type: 'SALES' | 'STOCK' | 'KEY_UPDATE', key: string) => {
  let dataToExport: any = {};
  
  if (type === 'SALES') {
    const pendingSales = await db.sales.where('sync_status').equals('pending').toArray();
    dataToExport = {
      type: 'SALES_REPORT',
      sales: pendingSales,
      timestamp: Date.now()
    };
  } else if (type === 'STOCK') {
    const masterStock = await db.products.toArray();
    dataToExport = {
      type: 'STOCK_UPDATE',
      products: masterStock,
      timestamp: Date.now()
    };
  } else if (type === 'KEY_UPDATE') {
    dataToExport = {
      type: 'KEY_UPDATE',
      new_key: key,
      timestamp: Date.now()
    };
  }

  const jsonString = JSON.stringify(dataToExport);
  const encrypted = xorCipher(jsonString, key);
  const compressed = LZString.compressToEncodedURIComponent(encrypted);
  
  // Add Header to identify valid NaijaShop data
  return SYNC_HEADER + compressed;
};

export const importWhatsAppBridgeData = async (rawString: string, localKey: string) => {
  try {
    // 1. Validate Header
    if (!rawString.startsWith(SYNC_HEADER)) {
      throw new Error("Invalid Data: This link was not generated by a NaijaShop Terminal.");
    }

    // 2. Extract and Decompress
    const compressed = rawString.replace(SYNC_HEADER, "");
    const encrypted = LZString.decompressFromEncodedURIComponent(compressed);
    if (!encrypted) throw new Error("Decompression failed. Data may be corrupt.");
    
    // 3. Decrypt
    const jsonString = xorCipher(encrypted, localKey);
    let payload;
    try {
      payload = JSON.parse(jsonString);
    } catch (e) {
      throw new Error("Sync Key Mismatch: Your terminal's security key does not match the sender's. Ask your Admin for an 'Emergency Key Update'.");
    }

    // 4. Process Payloads
    if (payload.type === 'KEY_UPDATE') {
      await db.settings.update('app_settings', { sync_key: payload.new_key });
      return { success: true, type: 'KEY_UPDATE' };
    }

    if (payload.type === 'SALES_REPORT') {
      let importedCount = 0;
      await (db as any).transaction('rw', [db.sales, db.products, db.inventory_logs], async () => {
        for (const sale of payload.sales) {
          const exists = await db.sales.where('timestamp').equals(sale.timestamp).first();
          if (!exists) {
            await db.sales.add({ ...sale, sync_status: 'synced' });
            for (const item of sale.items) {
              const p = await db.products.get(item.productId);
              if (p) {
                const oldStock = p.stock_qty;
                const newStock = Math.max(0, p.stock_qty - item.quantity);
                await db.products.update(item.productId, { stock_qty: newStock });
                await db.inventory_logs.add({
                  product_id: item.productId,
                  product_name: item.name,
                  quantity_changed: -item.quantity,
                  old_stock: oldStock,
                  new_stock: newStock,
                  type: 'Sale',
                  timestamp: Date.now(),
                  performed_by: 'Bridge (' + (sale.staff_id || 'Staff') + ')'
                });
              }
            }
            importedCount++;
          }
        }
      });
      return { success: true, type: 'SALES', count: importedCount };
    }

    if (payload.type === 'STOCK_UPDATE') {
      await (db as any).transaction('rw', [db.products], async () => {
        await db.products.clear();
        await db.products.bulkAdd(payload.products);
      });
      await db.settings.update('app_settings', { last_synced_timestamp: Date.now() });
      return { success: true, type: 'STOCK', count: payload.products.length };
    }

    throw new Error("Unknown payload type.");
  } catch (err: any) {
    console.error("Import Error:", err);
    throw err;
  }
};